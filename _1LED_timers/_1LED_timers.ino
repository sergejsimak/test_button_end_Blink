volatile bool timerLED1On;      //переменная вкл/выкл таймера
volatile unsigned long int timerLED1; //переменная подсчета миллисекунд

unsigned long int timerLED1Loop;  //переменная для хранения значения таймера
bool LED1On;  //переменная для хранения состояния светодиода

ISR (TIMER0_COMPA_vect) //функция, вызываемая таймером-счетчиком каждые 0,001 сек.
{ 
  if(timerLED1On)       //если включен миллисекудный таймер для LED1
  {
    timerLED1++;        //инкремент переменной таймера (+1)
  }
}

void setup() 
{
  pinMode(13, OUTPUT);    //настроить 13-й порт как "выход"
  /**** настройка прерывания по таймеру каждую 0,001 сек (вызов функции ISR (TIMER0_COMPA_vect)) ****/
  TCCR0A |= (1 << WGM01);              //сброс при совпадении
  OCR0A = 0xF9;                        //начало отсчета до переполнения (249)
  TIMSK0 |= (1 << OCIE0A);             //разрешить прерывание при совпадении с регистром А
  TCCR0B |= (1 << CS01) | (1 << CS00); //установить делитель частоты на 64 
  sei();                               //разрешить прерывания
}

void loop() 
{   
  timerLED1On = 1;    //разрешение инкремента переменной таймера timerLED1
  cli();              //остановка прерываний
  timerLED1Loop = timerLED1; //сохранение текущего значения таймера
  sei();              //разрешение прерываний

  if(timerLED1Loop >= 1000) //если таймер отсчитал больше заданного значения
  {     //то включить/выключить светодиод и обнулить таймер
    if(LED1On == 0)   //если светодиод был выключен
    {
      LED1On = 1;     //поставить флаг включения
      digitalWrite(13, LED1On);   //включить светодиод
    }
    else //иначе, если светодиод был выключен
    {
      LED1On = 0;     //поставить флаг выключения
      digitalWrite(13, LED1On);  //выключить светодиод
    }  
    cli();    //остановить прерыания
    timerLED1 = 0;  //обнулить таймер
    sei();    //запустить прерывания
  }
}









